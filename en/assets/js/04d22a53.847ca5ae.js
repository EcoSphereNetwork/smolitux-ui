"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7470],{8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},8525:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"testing/testplan/Spezielle-Komponententests","title":"Spezielle Komponententests","description":"Dieses Dokument beschreibt spezifische Teststrategien f\xfcr komplexere Komponententypen in der smolitux UI-Bibliothek.","source":"@site/docs/testing/testplan/05-Spezielle-Komponententests.md","sourceDirName":"testing/testplan","slug":"/testing/testplan/Spezielle-Komponententests","permalink":"/smolitux-ui/en/docs/testing/testplan/Spezielle-Komponententests","draft":false,"unlisted":false,"editUrl":"https://github.com/EcoSphereNetwork/smolitux-ui/tree/main/docs/docs/testing/testplan/05-Spezielle-Komponententests.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"wikiSidebar","previous":{"title":"Integrationstests f\xfcr komplexe Komponenten","permalink":"/smolitux-ui/en/docs/testing/testplan/Integrationstests"},"next":{"title":"Visuelle Regressionstests","permalink":"/smolitux-ui/en/docs/testing/testplan/Visuelle-Tests"}}');var s=t(4848),o=t(8453);const i={},a="Spezielle Komponententests",l={},c=[{value:"1. Form-Komponenten",id:"1-form-komponenten",level:2},{value:"1.1 Zu testende Aspekte bei Form-Komponenten",id:"11-zu-testende-aspekte-bei-form-komponenten",level:3},{value:"1.2 Beispiel: FormControl mit verschachtelten Elementen",id:"12-beispiel-formcontrol-mit-verschachtelten-elementen",level:3},{value:"5. Teststrategien f\xfcr Context-abh\xe4ngige Komponenten",id:"5-teststrategien-f\xfcr-context-abh\xe4ngige-komponenten",level:2},{value:"5.1 Context-Provider verwenden",id:"51-context-provider-verwenden",level:3},{value:"5.2 Context-Consumer testen",id:"52-context-consumer-testen",level:3},{value:"6. Tipps f\xfcr benutzerdefinierte Testhelfer",id:"6-tipps-f\xfcr-benutzerdefinierte-testhelfer",level:2},{value:"6.1 Benutzerdefinierte render-Funktion mit Providern",id:"61-benutzerdefinierte-render-funktion-mit-providern",level:3},{value:"6.2 H\xe4ufig ben\xf6tigte Testhelfer",id:"62-h\xe4ufig-ben\xf6tigte-testhelfer",level:3},{value:"2. Datums- und Zeit-Komponenten",id:"2-datums--und-zeit-komponenten",level:2},{value:"2.1 Zu testende Aspekte",id:"21-zu-testende-aspekte",level:3},{value:"2.2 Beispiel: DatePicker-Komponente",id:"22-beispiel-datepicker-komponente",level:3},{value:"3. Tabellenkomponenten",id:"3-tabellenkomponenten",level:2},{value:"3.1 Zu testende Aspekte",id:"31-zu-testende-aspekte",level:3},{value:"3.2 Beispiel: Erweiterte Tabellentests",id:"32-beispiel-erweiterte-tabellentests",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"spezielle-komponententests",children:"Spezielle Komponententests"})}),"\n",(0,s.jsx)(n.p,{children:"Dieses Dokument beschreibt spezifische Teststrategien f\xfcr komplexere Komponententypen in der smolitux UI-Bibliothek."}),"\n",(0,s.jsx)(n.h2,{id:"1-form-komponenten",children:"1. Form-Komponenten"}),"\n",(0,s.jsx)(n.p,{children:"Form-Komponenten stellen besondere Herausforderungen dar, da sie Benutzereingaben verarbeiten, Validierungen durchf\xfchren und komplexe Zust\xe4nde verwalten m\xfcssen."}),"\n",(0,s.jsx)(n.h3,{id:"11-zu-testende-aspekte-bei-form-komponenten",children:"1.1 Zu testende Aspekte bei Form-Komponenten"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Validierung und Fehlerbehandlung"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tests mit g\xfcltigen und ung\xfcltigen Eingaben"}),"\n",(0,s.jsx)(n.li,{children:"Anzeige und Format von Fehlermeldungen"}),"\n",(0,s.jsx)(n.li,{children:"Form-\xfcbergreifende Validierungsregeln"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Zust\xe4nde und Interaktionen"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Disabled/Enabled-Zustand"}),"\n",(0,s.jsx)(n.li,{children:"Fokus- und Blur-Events"}),"\n",(0,s.jsx)(n.li,{children:"Placeholder-Text und Hinweistexte"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Barrierefreiheit"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ARIA-Attribute und Rollen"}),"\n",(0,s.jsx)(n.li,{children:"Label-Verkn\xfcpfung"}),"\n",(0,s.jsx)(n.li,{children:"Unterst\xfctzung von Bildschirmlesern"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"12-beispiel-formcontrol-mit-verschachtelten-elementen",children:"1.2 Beispiel: FormControl mit verschachtelten Elementen"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// FormControl.test.tsx\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { FormControl } from '../FormControl';\nimport { Input } from '../../Input/Input';\nimport { Select } from '../../Select/Select';\nimport { Button } from '../../Button/Button';\n\nconst NestedForm = () => {\n  const [values, setValues] = React.useState({\n    name: '',\n    email: '',\n    role: ''\n  });\n\n## 4. Chart-Komponenten\n\nChart-Komponenten erfordern spezielle Testans\xe4tze, da sie visuell komplexe Daten darstellen und mit DOM-Elementen wie SVG interagieren.\n\n### 4.1 Zu testende Aspekte\n\n1. **Korrekte Datenvisualisierung**\n   - Pr\xfcfung der generierten SVG-Elemente\n   - Darstellung verschiedener Datens\xe4tze\n\n2. **Interaktivit\xe4t**\n   - Hover-Effekte und Tooltips\n   - Klickbare Bereiche und Legenden\n\n3. **Anpassbarkeit**\n   - Themes und Farbschemata\n   - Responsive Anpassung an Containergr\xf6\xdfen\n\n### 4.2 Beispiel: AreaChart-Komponente\n\n```tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { AreaChart } from '../AreaChart';\n\n// Mock f\xfcr useTheme hook\njest.mock('@smolitux/theme', () => ({\n  useTheme: () => ({ themeMode: 'light' })\n}));\n\ndescribe('AreaChart', () => {\n  const mockData = {\n    id: 'testSeries',\n    name: 'Test Data',\n    data: [\n      { x: 'Jan', y: 100 },\n      { x: 'Feb', y: 150 },\n      { x: 'Mar', y: 200 },\n      { x: 'Apr', y: 120 },\n      { x: 'May', y: 180 }\n    ]\n  };\n\n  test('renders chart with correct SVG elements', () => {\n    render(<AreaChart data={mockData} />);\n    \n    // SVG sollte gerendert werden\n    expect(screen.getByRole('img')).toBeInTheDocument();\n    \n    // Pr\xfcfen auf spezifische SVG-Elemente\n    const svg = document.querySelector('svg');\n    expect(svg).toBeInTheDocument();\n    \n    // Hintergrund-Rechteck sollte existieren\n    expect(svg?.querySelector('rect')).toBeInTheDocument();\n    \n    // Pr\xfcfen der Datenpunkte (Path-Elemente f\xfcr Linien)\n    expect(svg?.querySelectorAll('path').length).toBeGreaterThan(0);\n  });\n\n  test('renders chart with title', () => {\n    render(<AreaChart data={mockData} title=\"Test Chart\" />);\n    expect(screen.getByText('Test Chart')).toBeInTheDocument();\n  });\n\n  test('passes height and width properties correctly', () => {\n    render(<AreaChart data={mockData} height={400} width={800} />);\n    const svg = document.querySelector('svg');\n    expect(svg).toHaveAttribute('height', '400');\n    expect(svg).toHaveAttribute('width', '800');\n  });\n\n  test('shows points when showPoints is true', () => {\n    render(<AreaChart data={mockData} showPoints />);\n    const svg = document.querySelector('svg');\n    expect(svg?.querySelectorAll('circle').length).toBeGreaterThan(0);\n  });\n\n  test('hides points when showPoints is false', () => {\n    render(<AreaChart data={mockData} showPoints={false} />);\n    const svg = document.querySelector('svg');\n    expect(svg?.querySelectorAll('circle').length).toBe(0);\n  });\n\n  test('renders legend when showLegend is true', () => {\n    render(<AreaChart data={[mockData, {...mockData, id: 'second', name: 'Second Series'}]} showLegend />);\n    expect(screen.getByText('Test Data')).toBeInTheDocument();\n    expect(screen.getByText('Second Series')).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"5-teststrategien-f\xfcr-context-abh\xe4ngige-komponenten",children:"5. Teststrategien f\xfcr Context-abh\xe4ngige Komponenten"}),"\n",(0,s.jsx)(n.p,{children:"Viele Komponenten h\xe4ngen von Context ab, wie z.B. ThemeContext, FormContext oder AuthContext. Hier sind Strategien f\xfcr das Testen solcher Komponenten:"}),"\n",(0,s.jsx)(n.h3,{id:"51-context-provider-verwenden",children:"5.1 Context-Provider verwenden"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// ThemeAwareComponent.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { ThemeProvider } from '@smolitux/theme';\nimport { ThemeAwareComponent } from '../ThemeAwareComponent';\n\ndescribe('ThemeAwareComponent', () => {\n  test('renders with light theme by default', () => {\n    render(\n      <ThemeProvider>\n        <ThemeAwareComponent />\n      </ThemeProvider>\n    );\n    expect(screen.getByTestId('theme-component')).toHaveClass('bg-white');\n  });\n\n  test('renders with dark theme when provided', () => {\n    render(\n      <ThemeProvider initialTheme=\"dark\">\n        <ThemeAwareComponent />\n      </ThemeProvider>\n    );\n    expect(screen.getByTestId('theme-component')).toHaveClass('bg-gray-800');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"52-context-consumer-testen",children:"5.2 Context-Consumer testen"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// FormControl.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { FormControl, useFormControl } from '../FormControl';\nimport { Input } from '../../Input/Input';\n\n// Testkomponente, die den FormControl-Context verwendet\nconst FormControlConsumer = () => {\n  const context = useFormControl();\n  return (\n    <div data-testid=\"consumer\">\n      {JSON.stringify({\n        disabled: context.disabled,\n        required: context.required,\n        hasError: context.hasError,\n      })}\n    </div>\n  );\n};\n\ndescribe('FormControl Context', () => {\n  test('provides correct context values to children', () => {\n    render(\n      <FormControl disabled required error=\"Error message\">\n        <FormControlConsumer />\n      </FormControl>\n    );\n    \n    const consumer = screen.getByTestId('consumer');\n    expect(consumer).toHaveTextContent(/\"disabled\":true/);\n    expect(consumer).toHaveTextContent(/\"required\":true/);\n    expect(consumer).toHaveTextContent(/\"hasError\":true/);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"6-tipps-f\xfcr-benutzerdefinierte-testhelfer",children:"6. Tipps f\xfcr benutzerdefinierte Testhelfer"}),"\n",(0,s.jsx)(n.h3,{id:"61-benutzerdefinierte-render-funktion-mit-providern",children:"6.1 Benutzerdefinierte render-Funktion mit Providern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// test-utils.tsx\nimport React from 'react';\nimport { render, RenderOptions } from '@testing-library/react';\nimport { ThemeProvider } from '@smolitux/theme';\nimport { ToastProvider } from '@smolitux/toast';\n\n// Benutzerdefinierte render-Funktion, die alle ben\xf6tigten Provider enth\xe4lt\nconst customRender = (\n  ui: React.ReactElement,\n  options?: Omit<RenderOptions, 'wrapper'> & { theme?: 'light' | 'dark' }\n) => {\n  const { theme = 'light', ...rest } = options || {};\n  \n  return render(ui, {\n    wrapper: ({ children }) => (\n      <ThemeProvider initialTheme={theme}>\n        <ToastProvider>\n          {children}\n        </ToastProvider>\n      </ThemeProvider>\n    ),\n    ...rest,\n  });\n};\n\n// Export aller Funktionen aus testing-library/react\nexport * from '@testing-library/react';\n\n// \xdcberschreiben der render-Methode\nexport { customRender as render };\n"})}),"\n",(0,s.jsx)(n.h3,{id:"62-h\xe4ufig-ben\xf6tigte-testhelfer",children:"6.2 H\xe4ufig ben\xf6tigte Testhelfer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// test-helpers.tsx\nimport { fireEvent, waitFor } from '@testing-library/react';\n\n// Helfer f\xfcr Formular-Interaktionen\nexport const fillForm = async (getByLabelText, formData) => {\n  for (const [label, value] of Object.entries(formData)) {\n    const input = getByLabelText(label);\n    await fireEvent.change(input, { target: { value } });\n  }\n};\n\n// Helfer f\xfcr Modaltests\nexport const openAndVerifyModal = async (getByText, getByRole, buttonText) => {\n  fireEvent.click(getByText(buttonText));\n  \n  await waitFor(() => {\n    expect(getByRole('dialog')).toBeInTheDocument();\n  });\n};\n\n// Helfer f\xfcr Datumsmanipulation in Tests\nexport const setTestDate = (year, month, day) => {\n  jest.useFakeTimers();\n  jest.setSystemTime(new Date(year, month, day));\n  \n  return () => {\n    jest.useRealTimers();\n  };\n};\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const [errors, setErrors] = React.useState({\n  name: '',\n  email: ''\n});\n\nconst handleSubmit = (e: React.FormEvent) => {\n  e.preventDefault();\n\n  const newErrors = {\n    name: values.name ? '' : 'Name is required',\n    email: values.email ? '' : 'Email is required'\n  };\n\n  setErrors(newErrors);\n\n  if (Object.values(newErrors).every(error => !error)) {\n    console.log('Form submitted:', values);\n  }\n};\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"test('combines filtering and sorting correctly', async () => {\n    render(\n      <Table \n        data={testData} \n        columns={columns} \n        showSearch={true}\n        showPagination={true}\n        itemsPerPage={50}\n      />\n    );\n    \n    // Nach Kategorie A filtern\n    const filterButtons = screen.getAllByRole('button');\n    const categoryFilterButton = Array.from(filterButtons).find(\n      button => button.closest('th')?.textContent?.includes('Category')\n    );\n    \n    if (!categoryFilterButton) throw new Error('Filter button not found');\n    \n    fireEvent.click(categoryFilterButton);\n    \n    // Filterwert eingeben\n    const filterInput = await screen.findByPlaceholderText('Filterwert...');\n    await userEvent.type(filterInput, 'Category A');\n    \n    // Filter anwenden\n    fireEvent.click(screen.getByText('Anwenden'));\n    \n    // Pr\xfcfen, ob nur Kategorie A angezeigt wird\n    await waitFor(() => {\n      const categoryACells = screen.getAllByText('Category A');\n      expect(categoryACells.length).toBeGreaterThan(1); // Header + Zeilen\n      expect(screen.queryByText('Category B')).not.toBeInTheDocument();\n      expect(screen.queryByText('Category C')).not.toBeInTheDocument();\n    });\n    \n    // Nach Wert sortieren (aufsteigend)\n    const valueHeader = Array.from(screen.getAllByRole('columnheader')).find(\n      header => header.textContent?.includes('Value')\n    );\n    \n    if (!valueHeader) throw new Error('Value header not found');\n    \n    fireEvent.click(valueHeader);\n    \n    // Ersten und letzten Wert merken, um Sortierung zu pr\xfcfen\n    const valueRows = screen.getAllByRole('row').slice(1); // Header \xfcberspringen\n    const firstValue = parseFloat(valueRows[0].cells[4].textContent?.replace('\u20ac', '') || '0');\n    const lastValue = parseFloat(valueRows[valueRows.length - 1].cells[4].textContent?.replace('\u20ac', '') || '0');\n    \n    // Erster Wert sollte kleiner sein als der letzte\n    expect(firstValue).toBeLessThan(lastValue);\n  });\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"test('row selection works correctly with select all', async () => {\n    const onRowSelect = jest.fn();\n    \n    render(\n      <Table \n        data={testData.slice(0, 20)}\n        columns={columns}\n        selectable={true}\n        itemsPerPage={10}\n        onRowSelect={onRowSelect}\n      />\n    );\n    \n    // Alle Zeilen auf der ersten Seite ausw\xe4hlen\n    const selectAllCheckbox = screen.getByRole('checkbox', { name: /select all/i });\n    fireEvent.click(selectAllCheckbox);\n    \n    // Alle Checkboxen auf der ersten Seite sollten ausgew\xe4hlt sein\n    const checkboxes = screen.getAllByRole('checkbox');\n    checkboxes.forEach(checkbox => {\n      expect(checkbox).toBeChecked();\n    });\n    \n    // Callback sollte mit 10 ausgew\xe4hlten Zeilen aufgerufen worden sein\n    expect(onRowSelect).toHaveBeenCalledWith(expect.arrayContaining([\n      expect.objectContaining({ id: 1 }),\n      expect.objectContaining({ id: 10 })\n    ]));\n    expect(onRowSelect.mock.calls[0][0].length).toBe(10);\n    \n    // Zur zweiten Seite navigieren\n    fireEvent.click(screen.getByLabelText('Next slide') || screen.getByText('Weiter'));\n    \n    // Auf Seite 2 sollten Checkboxen nicht ausgew\xe4hlt sein\n    await waitFor(() => {\n      const page2Checkboxes = screen.getAllByRole('checkbox');\n      expect(page2Checkboxes[1]).not.toBeChecked(); // Erstes Datencheckbox\n    });\n    \n    // Eine Zeile auf Seite 2 ausw\xe4hlen\n    const page2FirstRowCheckbox = screen.getAllByRole('checkbox')[1];\n    fireEvent.click(page2FirstRowCheckbox);\n    \n    // Callback sollte mit 11 ausgew\xe4hlten Zeilen aufgerufen worden sein\n    expect(onRowSelect).toHaveBeenCalledWith(expect.arrayContaining([\n      expect.objectContaining({ id: 1 }),\n      expect.objectContaining({ id: 10 }),\n      expect.objectContaining({ id: 11 })\n    ]));\n    expect(onRowSelect.mock.calls[1][0].length).toBe(11);\n  });\n});\n  };\n\n  return (\n    <form onSubmit={handleSubmit} data-testid=\"form\">\n      <FormControl \n        label=\"Name\" \n        error={errors.name}\n        required\n      >\n        <Input\n          value={values.name}\n          onChange={(e) => setValues({...values, name: e.target.value})}\n          placeholder=\"Enter your name\"\n        />\n      </FormControl>\n      \n      <FormControl \n        label=\"Email\" \n        error={errors.email}\n        required\n      >\n        <Input\n          type=\"email\"\n          value={values.email}\n          onChange={(e) => setValues({...values, email: e.target.value})}\n          placeholder=\"Enter your email\"\n        />\n      </FormControl>\n      \n      <FormControl label=\"Role\">\n        <Select\n          options={[\n            { value: 'user', label: 'User' },\n            { value: 'admin', label: 'Admin' },\n            { value: 'editor', label: 'Editor' }\n          ]}\n          value={values.role}\n          onChange={(e) => setValues({...values, role: e.target.value})}\n        />\n      </FormControl>\n      \n      <Button type=\"submit\">Submit</Button>\n    </form>\n  );\n};\n\ndescribe('Form Integration', () => {\n  test('validates form fields correctly', async () => {\n    render(<NestedForm />);\n    \n    // Submit empty form\n    fireEvent.submit(screen.getByTestId('form'));\n    \n    // Check for error messages\n    expect(screen.getByText('Name is required')).toBeInTheDocument();\n    expect(screen.getByText('Email is required')).toBeInTheDocument();\n    \n    // Fill the form\n    await userEvent.type(screen.getByPlaceholderText('Enter your name'), 'Test User');\n    await userEvent.type(screen.getByPlaceholderText('Enter your email'), 'test@example.com');\n    \n    // Submit again\n    fireEvent.submit(screen.getByTestId('form'));\n    \n    // Error messages should be gone\n    expect(screen.queryByText('Name is required')).not.toBeInTheDocument();\n    expect(screen.queryByText('Email is required')).not.toBeInTheDocument();\n  });\n  \n  test('select component changes value correctly', async () => {\n    render(<NestedForm />);\n    \n    // Open select dropdown\n    const select = screen.getByRole('combobox');\n    await userEvent.click(select);\n    \n    // Select an option\n    await userEvent.click(screen.getByText('Admin'));\n    \n    // Value should be updated\n    expect(select).toHaveValue('admin');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"2-datums--und-zeit-komponenten",children:"2. Datums- und Zeit-Komponenten"}),"\n",(0,s.jsx)(n.p,{children:"Datums- und Zeit-Komponenten stellen spezielle Herausforderungen f\xfcr Tests dar, da sie mit dem aktuellen Datum/der aktuellen Zeit interagieren und komplexe Benutzerinteraktionen unterst\xfctzen m\xfcssen."}),"\n",(0,s.jsx)(n.h3,{id:"21-zu-testende-aspekte",children:"2.1 Zu testende Aspekte"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Datumsformatierung und -validierung"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Verschiedene Datumsformate testen"}),"\n",(0,s.jsx)(n.li,{children:"Valide und invalide Eingaben"}),"\n",(0,s.jsx)(n.li,{children:"Lokalisierung und Internationalisierung"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Navigation und Auswahl"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monats- und Jahresnavigation"}),"\n",(0,s.jsx)(n.li,{children:"Datumsauswahl via Klick"}),"\n",(0,s.jsx)(n.li,{children:"Tastaturnavigation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Einschr\xe4nkungen und Anpassungen"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Min/Max-Datum"}),"\n",(0,s.jsx)(n.li,{children:"Deaktivierte Termine"}),"\n",(0,s.jsx)(n.li,{children:"Benutzerdefinierte Datumsformatierung"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"22-beispiel-datepicker-komponente",children:"2.2 Beispiel: DatePicker-Komponente"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { DatePicker } from '../DatePicker';\n\ndescribe('DatePicker Complex Tests', () => {\n  beforeEach(() => {\n    // Konsistentes Datum f\xfcr Tests\n    jest.useFakeTimers();\n    jest.setSystemTime(new Date(2023, 0, 15)); // 15. Januar 2023\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n  });\n\n  test('respects min and max date constraints', async () => {\n    const minDate = new Date(2023, 0, 10); // 10. Januar 2023\n    const maxDate = new Date(2023, 0, 20); // 20. Januar 2023\n    \n    render(\n      <DatePicker \n        minDate={minDate}\n        maxDate={maxDate}\n      />\n    );\n    \n    // \xd6ffne den Datepicker\n    fireEvent.click(screen.getByRole('textbox'));\n    \n    // Vor dem minDate sollten Tage deaktiviert sein\n    await waitFor(() => {\n      const day5 = screen.getByText('5'); // 5. Januar\n      expect(day5.parentElement).toHaveClass('text-gray-400'); // Deaktivierte Klasse\n      expect(day5.parentElement).toHaveAttribute('aria-disabled', 'true');\n    });\n    \n    // Nach dem maxDate sollten Tage deaktiviert sein\n    const day25 = screen.getByText('25'); // 25. Januar\n    expect(day25.parentElement).toHaveClass('text-gray-400'); // Deaktivierte Klasse\n    expect(day25.parentElement).toHaveAttribute('aria-disabled', 'true');\n    \n    // Tag zwischen min und max sollte w\xe4hlbar sein\n    const day15 = screen.getByText('15'); // 15. Januar\n    expect(day15.parentElement).not.toHaveClass('text-gray-400');\n    expect(day15.parentElement).not.toHaveAttribute('aria-disabled', 'true');\n  });\n\n  test('handles different date formats correctly', async () => {\n    const onChange = jest.fn();\n    \n    render(\n      <DatePicker \n        format=\"dd.MM.yyyy\"\n        onChange={onChange}\n      />\n    );\n    \n    // \xd6ffne den Datepicker\n    fireEvent.click(screen.getByRole('textbox'));\n    \n    // Klicke auf den heutigen Tag\n    await waitFor(() => {\n      fireEvent.click(screen.getByText('15')); // 15. Januar\n    });\n    \n    // Input sollte im richtigen Format sein\n    expect(screen.getByRole('textbox')).toHaveValue('15.01.2023');\n    \n    // onChange sollte mit korrektem Datum aufgerufen werden\n    expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n    const calledDate = onChange.mock.calls[0][0];\n    expect(calledDate.getDate()).toBe(15);\n    expect(calledDate.getMonth()).toBe(0); // Januar\n    expect(calledDate.getFullYear()).toBe(2023);\n  });\n\n  test('allows manual date input when allowKeyboardInput is true', async () => {\n    const onChange = jest.fn();\n    \n    render(\n      <DatePicker \n        allowKeyboardInput={true}\n        format=\"yyyy-MM-dd\"\n        onChange={onChange}\n      />\n    );\n    \n    // Manuell Datum eingeben\n    const input = screen.getByRole('textbox');\n    await userEvent.clear(input);\n    await userEvent.type(input, '2023-02-20');\n    \n    // Enter dr\xfccken oder blur ausl\xf6sen\n    fireEvent.blur(input);\n    \n    // onChange sollte mit korrektem Datum aufgerufen werden\n    expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n    const calledDate = onChange.mock.calls[0][0];\n    expect(calledDate.getDate()).toBe(20);\n    expect(calledDate.getMonth()).toBe(1); // Februar\n    expect(calledDate.getFullYear()).toBe(2023);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"3-tabellenkomponenten",children:"3. Tabellenkomponenten"}),"\n",(0,s.jsx)(n.p,{children:"Tabellen sind komplexe Komponenten, die Datenfilterung, Sortierung, Paginierung und andere Funktionen unterst\xfctzen k\xf6nnen."}),"\n",(0,s.jsx)(n.h3,{id:"31-zu-testende-aspekte",children:"3.1 Zu testende Aspekte"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Datenoperationen"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sortierung (aufsteigend/absteigend)"}),"\n",(0,s.jsx)(n.li,{children:"Filterung nach verschiedenen Kriterien"}),"\n",(0,s.jsx)(n.li,{children:"Paginierung"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Zeilenfunktionen"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Zeilenauswahl (einzeln/mehrfach)"}),"\n",(0,s.jsx)(n.li,{children:"Aktionen pro Zeile"}),"\n",(0,s.jsx)(n.li,{children:"Expansion/Collapse von Details"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Darstellungsoptionen"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Anzahl von Elementen pro Seite"}),"\n",(0,s.jsx)(n.li,{children:"Spaltenbreite und -anpassungen"}),"\n",(0,s.jsx)(n.li,{children:"Layoutvarianten (gestreift, mit Rahmen, etc.)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"32-beispiel-erweiterte-tabellentests",children:"3.2 Beispiel: Erweiterte Tabellentests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { Table } from '../Table';\n\ndescribe('Table Advanced Tests', () => {\n  const testData = Array.from({ length: 50 }).map((_, index) => ({\n    id: index + 1,\n    name: `Item ${index + 1}`,\n    category: index % 3 === 0 ? 'Category A' : index % 3 === 1 ? 'Category B' : 'Category C',\n    status: index % 4 === 0 ? 'active' : index % 4 === 1 ? 'inactive' : index % 4 === 2 ? 'pending' : 'archived',\n    value: Math.round(Math.random() * 1000) / 10\n  }));\n\n  const columns = [\n    {\n      id: 'id',\n      header: 'ID',\n      accessor: (row: any) => row.id\n    },\n    {\n      id: 'name',\n      header: 'Name',\n      accessor: (row: any) => row.name,\n      sortable: true\n    },\n    {\n      id: 'category',\n      header: 'Category',\n      accessor: (row: any) => row.category,\n      filterable: true,\n      sortable: true\n    },\n    {\n      id: 'status',\n      header: 'Status',\n      accessor: (row: any) => row.status,\n      filterable: true,\n      sortable: true\n    },\n    {\n      id: 'value',\n      header: 'Value',\n      accessor: (row: any) => row.value,\n      sortable: true,\n      cell: (value: number) => `${value.toFixed(1)}\u20ac`\n    }\n  ];\n\n  test('pagination controls change page correctly', async () => {\n    render(\n      <Table \n        data={testData} \n        columns={columns} \n        showPagination={true}\n        itemsPerPage={10}\n      />\n    );\n    \n    // Erste Seite sollte die ersten 10 Items zeigen\n    expect(screen.getByText('Item 1')).toBeInTheDocument();\n    expect(screen.getByText('Item 10')).toBeInTheDocument();\n    expect(screen.queryByText('Item 11')).not.toBeInTheDocument();\n    \n    // Zur zweiten Seite navigieren\n    fireEvent.click(screen.getByLabelText('Next slide') || screen.getByText('Weiter'));\n    \n    // Zweite Seite sollte Items 11-20 zeigen\n    await waitFor(() => {\n      expect(screen.queryByText('Item 1')).not.toBeInTheDocument();\n      expect(screen.getByText('Item 11')).toBeInTheDocument();\n      expect(screen.getByText('Item 20')).toBeInTheDocument();\n    });\n    \n    // Zur letzten Seite springen\n    const lastPageButton = Array.from(screen.getAllByRole('button')).find(\n      button => button.textContent === '5'\n    );\n    \n    if (lastPageButton) {\n      fireEvent.click(lastPageButton);\n      \n      // Letzte Seite sollte Items 41-50 zeigen\n      await waitFor(() => {\n        expect(screen.queryByText('Item 20')).not.toBeInTheDocument();\n        expect(screen.getByText('Item 41')).toBeInTheDocument();\n        expect(screen.getByText('Item 50')).toBeInTheDocument();\n      });\n    }\n  });\n});\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);