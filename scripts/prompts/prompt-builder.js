#!/usr/bin/env node

/**
 * Smolitux UI Prompt Builder
 * 
 * This script builds modular prompts for Codex agents by combining:
 * 1. Base system prompt
 * 2. Package-specific instructions
 * 3. Task-specific workflows
 * 4. Reusable templates
 * 
 * Usage:
 * node prompt-builder.js --base core/system-prompt.md --package core --task component-development --template component
 */

const fs = require('fs');
const path = require('path');
const { program } = require('commander');

// Define the prompt directory
const PROMPT_DIR = path.join(__dirname, '..', '..', 'docs', 'prompts');

// Parse command line arguments
program
  .option('--base <path>', 'Base system prompt path (relative to prompts directory)')
  .option('--package <name>', 'Package name (core, theme, etc.)')
  .option('--task <name>', 'Task name (component-development, testing, etc.)')
  .option('--template <name>', 'Template name (component, test, story, etc.)')
  .option('--output <path>', 'Output file path (defaults to stdout)')
  .parse(process.argv);

const options = program.opts();

// Validate required options
if (!options.base) {
  console.error('Error: Base system prompt is required');
  process.exit(1);
}

// Function to read a prompt file
function readPromptFile(relativePath) {
  const fullPath = path.join(PROMPT_DIR, relativePath);
  try {
    return fs.readFileSync(fullPath, 'utf8');
  } catch (error) {
    console.error(`Error reading file ${fullPath}: ${error.message}`);
    return null;
  }
}

// Function to build the prompt
function buildPrompt() {
  // Read the base system prompt
  const basePrompt = readPromptFile(options.base);
  if (!basePrompt) {
    console.error('Error: Could not read base system prompt');
    process.exit(1);
  }

  // Initialize the prompt parts array
  const promptParts = [basePrompt];

  // Add package-specific prompt if specified
  if (options.package) {
    const packagePrompt = readPromptFile(`packages/${options.package}.md`);
    if (packagePrompt) {
      promptParts.push('\n\n## Package-Specific Instructions\n\n');
      promptParts.push(packagePrompt);
    } else {
      console.warn(`Warning: Package prompt for ${options.package} not found`);
    }
  }

  // Add task-specific prompt if specified
  if (options.task) {
    const taskPrompt = readPromptFile(`workflows/${options.task}.md`);
    if (taskPrompt) {
      promptParts.push('\n\n## Task-Specific Workflow\n\n');
      promptParts.push(taskPrompt);
    } else {
      console.warn(`Warning: Task prompt for ${options.task} not found`);
    }
  }

  // Add template prompt if specified
  if (options.template) {
    const templatePrompt = readPromptFile(`templates/${options.template}.md`);
    if (templatePrompt) {
      promptParts.push('\n\n## Code Templates\n\n');
      promptParts.push(templatePrompt);
    } else {
      console.warn(`Warning: Template prompt for ${options.template} not found`);
    }
  }

  // Combine all prompt parts
  const fullPrompt = promptParts.join('');

  // Add a footer
  const footer = `\n\n---\n\nThis prompt was generated by the Smolitux UI Prompt Builder on ${new Date().toISOString()}\n`;
  
  return fullPrompt + footer;
}

// Build the prompt
const prompt = buildPrompt();

// Output the prompt
if (options.output) {
  try {
    fs.writeFileSync(options.output, prompt);
    console.log(`Prompt written to ${options.output}`);
  } catch (error) {
    console.error(`Error writing to ${options.output}: ${error.message}`);
    process.exit(1);
  }
} else {
  console.log(prompt);
}